# 思路：贪心法
# 由于要分成连续的短，所以我们要使得每一段的值越大越好，但是不能超过k
# 那么对于每一个值如何与当前的段做按位或运算的结果不超过k，那么就可以添加到当前的段中，否则就开启一个新的段，并且重新设置当前的值为这一段的值
n, k = map(int, input().split())
a = list(map(int, input().split()))


ans = 1 # 最少的段数
cur = 0 # 当前子段的位运算结果
for i in range(n):
    if a[i]>k: # 如果数组中有一个元素值已经大于了k，那么直接返回-1即可，此时不管将该元素值划分到哪个段中都会超过
        print(-1)
        exit()
    cur|=a[i] # 位运算，将当前元素加入到当前子段中
    if cur>k: # 如果加入了元素后超过了k，那么要重新划分一个子段
        cur = a[i]
        ans+=1
print(ans)